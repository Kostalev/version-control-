# Введение в контроль версий

## Язык разметки Markdown

1. Блочные элементы
    * [Заголовки](#заголовки) 
    * [Цитаты](#цитаты);
    * [Списки](#списки);
    * [Блоки кода](#блоки-кода);
    * [Горизонтальные (разделительные) линии](#горизонтальные-разделительные-линии).
2. Строчные элементы
    * [Ссылки](#ссылки);
    * [Выделение текста](#выделение-текста);
    * [Кодовые фрагменты строк](#кодовые-фрагменты-строк);
    * [Изображения](#изображения);   
    * [Дополнительные элементы](#дополнительные-элементы).

## GIT - инструмент для контроля версий

1. Установка и настройка
    * [Создание нового репозитория](#создание-нового-репозитория);
    * [Определение состояния](#определение-состояния);
    * [Подготовка файлов](#подготовка-файлов)
2. Фиксация изменений
    * [Как сделать коммит](#как-сделать-коммит);
    * [Как посмотреть коммиты](#как-посмотреть-коммиты);
    * [Отслеживание изменений, сделанных в коммитах](#отслеживание-изменений-сделанных-в-коммитах);
    * [Возвращение файла к предыдущему состоянию](#возвращение-файла-к-предыдущему-состоянию);
    * [Исправление коммита](#исправление-коммита)
3. Удаленные репозитории
    * [Что такое удаленный репозиторий](#что-такое-удаленный-репозиторий);
    * [Подключение к удаленному репозиторию](#подключение-к-удаленному-репозиторию);
    * [Отправка изменений на сервер](#отправка-изменений-на-сервер);
    * [Запрос изменений с сервера](#запрос-изменений-с-сервера);
4. Ветвление
    * [Создание новой ветки](#создание-новой-ветки);
    * [Переключение между ветками](#переключение-между-ветками);
    * [Слияние веток](#слияние-веток);
    * [Разрешение конфликтов при слиянии](#разрешение-конфликтов-при-слиянии)
5. Настройка *.gitignore*
    * [Создание файла *.gitignore*](#создание-файла-gitignore);
    * [Примеры файлов](#примеры-файлов)
6. [Git bash и git.io](#6--git-bash-и-gitio) 
7. [Шпаргалка по основным командам](#7--шпаргалка-по-основным-командам)

# Введение в контроль версий

## Язык разметки Markdown

1. Блочные элементы
    
    * ### Заголовки;

        **Параграфы и разрывы строк**

        Для того, чтобы создать параграф с использованием синтаксиса языка Markdown, достаточно отделить строки текста одной (или более) пустой строкой (пустой считается всякая строка, которая не содержит в себе ничего, кроме пробелов и символов табуляции).

        Для того, чтобы вставить видимый перенос строки необходимо окончить строку двумя пробелами и нажатием клавиши «Enter»
    
        **Заголовки**

        Язык разметки Markdown поддерживает 2 стиля обозначения заголовков: подчеркивание и выделение символом («#»). Выделение заголовков с помощью подчеркивания производится знаками равенства («=») в случае, если заголовок первого уровня, и дефисами («-») в случае, если заголовок второго уровня. Количество знаков подчеркивания не ограничивается. При выделении заголовков с помощью символа («#») используется от одного до шести данных символов, которые устанавливаются в начале строки (перед заголовком). В данном случае количество символов соответствует уровню заголовка.
    
        **Примеры**

        # Заголовок первого уровня

        ## Заголовок второго уровня
        
        Заголовок первого уровня с подчеркиванием 
        ===
        ## Заголовок второго уровня с подчеркиванием
        ---
    
    * ### Цитаты;

      Для обозначения цитат в языке Markdown используется знак «больше» («>»). Его можно вставлять как перед каждой строкой цитаты, так и только перед первой строкой параграфа. Также синтаксис Markdown позволяет создавать вложенные цитаты (цитаты внутри цитат). Для их разметки используются дополнительные уровни знаков цитирования («>»). Цитаты в Markdown могут содержать всевозможные элементы разметки. Цитаты в языке Markdown выглядят следующим образом:

      >Это пример цитаты

      Вложение цитаты в цитату выглядит следующим образом:

      > Первый уровень цитирования
      >> Второй уровень цитирования
      >>> Третий уровень цитирования

      Уровень цитирования не может превышать 15-й.

    * ### Списки;

      Markdown поддерживает упорядоченные (нумерованные) и неупорядоченные (ненумерованные) списки. Для формирования неупорядоченный списков используются такие маркеры, как звездочки, плюсы и дефисы. Все перечисленные маркеры могут использоваться взаимозаменяемо. Для формирования упорядоченных списков в качестве маркеров используются числа с точкой. Важной особенностью в данном случае является то, что сами номера, с помощью которых формируется список, не важны, так как они не оказывают влияния на выходной HTML код. Как бы ни нумеровал пользователь список, на выходе он в любом случае будет иметь упорядоченный список, начинающийся с единицы (1, 2, 3…). Эту особенность стоит учитывать в том случае, когда необходимо использовать порядковые номера элементов в списке, чтобы они соответствовали номерам, получающимся в HTML. Упорядоченные списки всегда следует начинать с единицы. Маркеры списков обычно начинаются с начала строки, однако они могут быть сдвинуты, но не более чем на 3 пробела. За маркером должен следовать пробел, либо символ табуляции. При необходимости в список можно вставить цитату. В этом случае обозначения цитирования ( «>» ) нужно писать с отступом. Упорядоченные списки выглядят следующим образом:

      1. Первый элемент
            > цитата
      2. Второй элемент
            > цитата
      3. Третий элемент

      При вставке цитат в элементы списка важно учитывать, что элементы списка должны находиться на одном уровне, а цитаты должны указываться с отступом. В случае, если правило с единым уровнем списка не соблюдается, следующий после цитаты элемент списка будет автоматически нумероваться цифрой «1.». Кроме того, при необходимости в список можно вставить исходный код. В этом случае его нужно писать с двойным отступом – 8 пробелов или 2 символа табуляции.

      Неупорядоченные списки выглядят следующим образом:

        * Элемент 1
        * Элемент 2
        * Элемент 3

        Или

        - Элемент 1
        - Элемент 2
        - Элемент 3

        Или

        + Элемент 1
        + Элемент 2
        + Элемент 3

      При необходимости в список можно вставить исходный код. В этом случае его нужно писать с двойным отступом – 8 пробелов или 2 символа табуляции.

      Пример:

      * Элемент списка
        
                исходный код

    * ### Блоки кода;

      Отформатированные блоки кода используются в случае необходимости процитировать исходный код программ или разметки. Для создания блока кода в языке Markdown необходимо каждую строку параграфа начинать с отступа, состоящего из четырех пробелов или одного символа табуляции. Блок кода продолжается до тех пор, пока не встретится строка без отступа (или конец текста). Внутри блока кода амперсанды («&») и угловые скобки («<» и «>») автоматически преобразуются в элементы HTML разметки. Кроме того, следует отметить, что внутри блоков кода обычный синтаксис Markdown не обрабатывается. Блок кода в Markdown выглядит следующим образом:

      Это обычный параграф:
            
            блок кода
    
    * ### Горизонтальные (разделительные) линии.

      Для того чтобы создать горизонтальную линию с использованием синтаксиса языка Markdown, необходимо поместить три (или более)дефиса или звездочки на отдельной строке текста. Между ними возможно располагать пробелы. Горизонтальные линии в Markdown выглядят следующим образом:

      Первая часть текста, который необходимо разделить
      ***
      Вторая часть текста, который необходимо разделить

      При использовании данного инструмента важно помнить, что после первой части текста и перед второй необходимо оставлять пустую строку. Данное правило необходимо соблюдать только при использовании дефисов. Если его не соблюдать, на экран будет выведен заголовок второго уровня и строка обычного текста. При использовании символа звездочки данным правилом можно пренебречь.


2. Строчные элементы
    * ### Ссылки;

        Markdown поддерживает два стиля оформления ссылок:

        * Гиперссылка, с немедленным указанием адреса (внутритекстовая);
        * Гиперссылка, подобная сноске.

        Подразумевается, что помимо URL-адреса существует еще текст ссылки. Он заключается в квадратные скобки. Для создания внутритекстовой гиперссылки необходимо использовать круглые скобки сразу после закрывающей квадратной. Внутри них необходимо поместить URL-адрес. В них же возможно расположить название, заключенное в кавычки, которое будет отображаться при наведении, но этот пункт не является обязательным.

            [пример](http://example.com/ "Необязательная подсказка")
        
        В результате на экран выводится следующее:
        
         [пример](http://example.com/ "Необязательная подсказка")

        При создании сносной гиперссылки вместо целевого адреса используется вторая пара квадратных скобок, внутри которых помещается метка, идентификатор ссылки (id).

                [пример][id]:

        Также, можно использовать пробел, чтобы отделять 2 пары квадратных скобок:

                [пример] [id]: 

        В этом случае возможно определить идентификатор в любом месте документа:

                [id]: http://example.com/ "Необязательная подсказка"
        
        она состоит из следующих элементов:

        * Идентификатор ссылки, окружённый квадратными скобками (которым может предшествовать необязательный отступ от одного до трёх пробелов);
        * Двоеточие;
        * Один или несколько пробелов (или символов табуляции);
        * URL гиперссылки;
        * Необязательный заголовок (подсказка к изображению, которая всплывает при наведении на него) гиперссылки, заключённый либо в двойные или одиночные кавычки, либо в скобки.

        Идентификаторы ссылок могут состоять из букв, цифр, пробелов и знаков пунктуации, однако они не чувствительны к регистру.

        Автоматические ссылки

        Markdown поддерживает упрощённый порядок автоматического создания ссылок для URL-адресов и адресов электронной почты. Для этого достаточно поместить URL-адрес или почтовый адрес в угловые скобки, и Markdown сделает его гиперссылкой. В отличие от вышеописанных стилей, в данном случае сам же URL-адрес или почтовый адрес становится и текстом гиперссылки. Автоматические ссылки на адреса электронной почты работают аналогично. Автоматические ссылки в языке Markdown выглядят следующим образом

            <http://example.com/>
        В результате на экран выводится следующее: http://example.com/

        Автоматическая ссылка на адрес электронной почты в Markdown выглядит следующим образом

            <address@example.com>
        В результате на экран выводится следующее: address@example.com

    * ### Выделение текста;

        Markdown воспринимает звёздочки «*» и символы подчёркивания «_» как признаки смыслового выделения текста:

            Текст, окружённый одиночными «*» или «_», будет заключен в HTML-тэг <em>.
            Текст, окружённый двойными «*» или «_», будет заключен в HTML-тэг <strong>.
        
        Иными словами, текст, окруженный одинарными символами, выделяется курсивным шрифтом, а текст, окруженный двойными символами, выделяется полужирным шрифтом. Также, выделенный фрагмент может находиться в любой части слова.

        Текст, выделенный курсивом с использованием синтаксиса языка Markdown, выглядит следующим образом:

            *Пример*  
        *Пример*

        Текст, выделенный полужирным шрифтом с использованием синтаксиса языка Markdown, выглядит следующим образом:

            **Пример**
        **Пример**

        Текст, выделенный курсивным полужирным шрифтом с использованием синтаксиса языка Markdown выглядит следующим образом:

            ***Пример***
        ***Пример***

    * ### Кодовые фрагменты строк;

      Чтобы отметить фрагмент строки, содержащий код, необходимо окружить его обратными апострофами «`». При использовании кодовых фрагментов строк текст будет отображаться в виде моноширинного шрифта. В отличие от блоков кода, кодовый фрагмент позволяет поместить код внутрь обычного абзаца текста. Кодовый фрагмент строки в языке Markdown выглядит следующим образом:

            Используйте оператор <<if>>  

    * ### Изображения. 

      В Markdown существует 2 способа вставки изображений в документ:

      * С помощью непосредственного указания URL-адреса изображения. Синтаксис   данной команды выглядит следующим образом:
        
                ![Альтернативный текст](/путь/к/изображению.jpg)
        или

                ![Альтернативный текст](/путь/к/изображению.jpg "Подсказка")  

        Иными словами, он состоит из следующих элементов:

        * восклицательный знак;
        * квадратные скобки, в которых указывается альтернативный изображению текст (он станет содержимым атрибута в элементе img);
        * круглые скобки, содержащие URL-адрес или относительный путь изображения, а также (необязательно) всплывающую подсказку, заключённуе в двойные или одиночные кавычки.
      * С помощью метки-идентификатора. Синтаксис данной команды записывается следующим образом:

            ![Альтернативный текст][id]
        
        где «id» — имя определённой метки изображения. Метки изображений определяются при помощи синтаксиса, совершенно идентичного меткам гиперссылок:

            [id]: путь/к/изображению "Необязательная подсказка"
        
        Важной особенностью является то, что Markdown не позволяет задать размеры изображения (ширину, высоту).

    * ### Дополнительные элементы;

      Обратный слеш  

      Может употребляться в Markdown перед специальными символами для того, чтобы они воспринимались в их буквальном (а не служебном) значении. Полный список данных символов приводится ниже:

        «\» - слеш;

        «`» - обратный апостроф;

        «*» - звездочка;

        «_» - символ подчеркивания;

        «{}» - фигурные скобки;

        «[]» - квадратные скобки;

        «()» - круглые скобки;

        «#» - символ решетки;

        «+» - плюс;

        «-» - минус (дефис);

        «.» – точка;

        «!» - восклицательный знак.


 
## GIT - инструмент для контроля версий

Git — это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще всего речь идет об исходном коде программ, но вы можете использовать его для любых файлов на ваш вкус). Изначально Git был создан Линусом Торвальдсом при разработке ядра Linux. Однако инструмент так понравился разработчикам, что в последствии, он получил широкое распространение и его стали использовать в других проектах. С его помощью вы можете сравнивать, анализировать, редактировать, сливать изменения и возвращаться назад к последнему сохранению. Этот процесс называется контролем версий.

Он нужен, чтобы отследить изменения, произошедшие с проектом, со временем. Проще говоря, мы можем посмотреть как менялись файлы программы, на всех этапах разработки и при необходимости вернуться назад и что-то отредактировать. Часто бывают ситуации, когда, во вполне себе работающий код, вам нужно внести определенные правки или улучшить какой-то функционал, по желанию заказчика.

Он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом. Без Гита случится коллапс, когда разработчики, скопировав весь код из главной папки и сделав с ним задуманное, попытаются одновременно вернуть весь код обратно.
Git является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в директориях на жестком диске, которые называются репозиторием. Тем не менее, вы можете хранить копию репозитория онлайн, это сильно облегчает работу над одним проектом для нескольких людей. Для этого используются сайты вроде github и bitbucket.

1. Установка и настройка

    Установить git на свою машину очень просто:

      * Linux — нужно просто открыть терминал и установить приложение при помощи пакетного менеджера вашего дистрибутива. Для Ubuntu команда будет выглядеть следующим образом:

            sudo apt-get install git
      * Windows — мы рекомендуем git for windows, так как он содержит и клиент с графическим интерфейсом, и эмулятор bash.
      * OS X — проще всего воспользоваться homebrew. После его установки запустите в терминале:

            brew install git  

    * ### Создание нового репозитория;

        После установки, нужно добавить немного настроек. Есть довольно много опций, с которыми можно играть, но мы настроим самые важные: наше имя пользователя и адрес электронной почты. Откройте терминал и запустите команды:

            git config --global user.name "My Name"
            git config --global user.email myEmail@example.com

        Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.
        Git хранит весь пакет конфигураций в файле .gitconfig, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг –global. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.
        Для того, чтобы посмотреть все настройки системы, используйте команду:

            git config --list
        
        Для удобства и легкости зрительного восприятия, некоторые группы команд в Гит можно выделить цветом, для этого нужно прописать в консоли:

            git config --global color.ui true
            git config --global color.status auto
            git config --global color.branch auto

        Если вы не до конца настроили систему для работы, Git всегда подскажет разработчику, если тот запутался, например:

        * Команда git --help - выводит общую документацию по git
        * Если введем git log --help - он предоставит нам документацию по какой-то определенной команде (в данном случае это - log)
        * Если вы вдруг сделали опечатку - система подскажет вам нужную команду
        * После выполнения любой команды - отчитается о том, что вы натворили
        * Также Гит прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше

        Тут стоит отметить, что подсказывать система будет на английском.

        Git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду init. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.
        Создайте на рабочем столе папку под названием git_exercise. Для этого в окне терминала введите:

            $ mkdir Desktop/git_exercise/
            $ cd Desktop/git_exercise/
            $ git init

        Командная строка должна вернуть что-то вроде:

            Initialized empty Git repository in /home/user/Desktop/git_exercise/.git/

        Это значит, что наш репозиторий был успешно создан, но пока что пуст. Теперь создайте текстовый файл под названием hello.txt и сохраните его в директории git_exercise.

    * ### Определение состояния;

        status — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск git status на нашем свежесозданном репозитории должен выдать:

            $ git status
            On branch master
            Initial commit
            Untracked files:
            (use "git add ..." to include in what will be committed)
            hello.txt

        Сообщение говорит о том, что файл hello.txt неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.

    * ### Подготовка файлов

        В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой add и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой commit.
        В нашем случае у нас только один файл, так что добавим его:

            $ git add hello.txt

        Если нам нужно добавить все, что находится в директории, мы можем использовать

            $ git add -A

        Проверим статус снова, на этот раз мы должны получить другой ответ:

            $ git status
            On branch master
            Initial commit
            Changes to be committed:
            (use "git rm --cached ..." to unstage)
            new file: hello.txt

        Файл готов к коммиту. Сообщение о состоянии также говорит нам о том, какие изменения относительно файла были проведены в области подготовки — в данном случае это новый файл, но файлы могут быть модифицированы или удалены.
        
2. Фиксация изменений
    * ### Как сделать коммит;

        Представим, что нам нужно добавить пару новых блоков в html-разметку (index.html) и стилизовать их в файле style.css. Для сохранения изменений, их необходимо закоммитить. Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды git add, добавляющей (или подготавливающей) их к коммиту. Добавлять их можно по отдельности:

            git add index.html
            git add css/style.css
        
        или вместе - всё сразу:

            git add .

        Конечно добавлять всё сразу удобнее, чем прописывать каждую позицию отдельно. Однако, тут надо быть внимательным, чтобы не добавить по ошибке ненужные элементы. Если же такое произошло изъять оттуда ошибочный файл можно при помощи команды

            git reset:
            git reset css/style.css

        Теперь создадим непосредственно сам коммит

            git commit -m 'Add some code'

        Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»

    * ### Как посмотреть коммиты;

        Для просмотра все выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:

            git log

        В ней содержиться вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды git show :

            git show hash_commit

        Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:

            git commit --amend -m 'Новый комментарий'

        В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.

    * ### Отслеживание изменений, сделанных в коммитах;

        У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду git log:

            $ git log
            commit ba25c0ff30e1b2f0259157b42b9f8f5d174d80d7
            Author: Tutorialzine
            Date: Mon May 30 17:15:28 2016 +0300
            New feature complete
            commit b10cc1238e355c02a044ef9f9860811ff605c9b4
            Author: Tutorialzine
            Date: Mon May 30 16:30:04 2016 +0300
            Added content to hello.txt
            commit 09bd8cc171d7084e78e4d118a2346b7487dca059
            Author: Tutorialzine
            Date: Sat May 28 17:52:14 2016 +0300
            Initial commit

        Как вы можете заметить, идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых нескольких символов будет вполне достаточно. Чтобы посмотреть, что нового появилось в коммите, мы можем воспользоваться командой git show [commit]

            $ git show b10cc123
            commit b10cc1238e355c02a044ef9f9860811ff605c9b4
            Author: Tutorialzine
            Date: Mon May 30 16:30:04 2016 +0300
            Added content to hello.txt
            diff --git a/hello.txt b/hello.txt
            index e69de29..b546a21 100644
            --- a/hello.txt
            +++ b/hello.txt
            @@ -0,0 +1 @@
            +Nice weather today, isn't it?

        Чтобы увидеть разницу между двумя коммитами, используется команда diff (с указанием промежутка между коммитами)

            $ git diff 09bd8cc..ba25c0ff
            diff --git a/feature.txt b/feature.txt
            new file mode 100644
            index 0000000..e69de29
            diff --git a/hello.txt b/hello.txt
            index e69de29..b546a21 100644
            --- a/hello.txt
            +++ b/hello.txt
            @@ -0,0 +1 @@
            +Nice weather today, isn't it?

        Мы сравнили первый коммит с последним, чтобы увидеть все изменения, которые были когда-либо сделаны. Обычно проще использовать git difftool, так как эта команда запускает графический клиент, в котором наглядно сопоставляет все изменения.

    * ### Возвращение файла к предыдущему состоянию;

        Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Это делается уже знакомой нам командой checkout, которую мы ранее использовали для переключения между ветками. Но она также может быть использована для переключения между коммитами (это довольно распространенная ситуация для Гита - использование одной команды для различных, на первый взгляд, слабо связанных задач).
        В следующем примере мы возьмем файл hello.txt и откатим все изменения, совершенные над ним к первому коммиту. Чтобы сделать это, мы подставим в команду идентификатор нужного коммита, а также путь до файла:

            $ git checkout 09bd8cc1 hello.txt

    * ### Исправление коммита

      сли вы опечатались в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, вы легко можете это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает вам возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.
      Для более сложных исправлений, например, не в последнем коммите или если вы успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным  идентификатором.
      Самый последний коммит может быть доступен по алиасу HEAD:

            $ git revert HEAD

      Для остальных будем использовать идентификаторы:

          $ git revert b10cc123

      При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.  

3. Удаленные репозитории

    Сейчас наш коммит является локальным — существует только в директории .git на нашей файловой системе. Несмотря на то, что сам по себе локальный репозиторий полезен, в большинстве случаев мы хотим поделиться нашей работой или доставить код на сервер, где он будет выполняться.

    * ### Что такое удаленный репозиторий;

        Репозиторий, хранящийся в облаке, на стороннем сервисе, специально созданном для работы с git имеет ряд преимуществ. Во-первых - это своего рода резервная копия вашего проекта, предоставляющая возможность безболезненной работы в команде. А еще в таком репозитории можно пользоваться дополнительными возможностями хостинга. К примеру -визуализацией истории или возможностью разрабатывать вашу программу непосредственно в веб-интерфейсе.
    
        **Клонирование**

        Клонирование - это когда вы копируете удаленный репозиторий к себе на локальный ПК. Это то, с чего обычно начинается любой проект. При этом вы переносите себе все файлы и папки проекта, а также всю его историю с момента его создания. Чтобы склонировать проект, сперва, необходимо узнать где он расположен и скопировать ссылку на него. В нашем руководстве мы будем использовать адрес https://github.com/tutorialzine/awesome-project, но вам посоветуем, попробовать создать свой репозиторий в GitHub, BitBucket или любом другом сервисе:

            git clone https://github.com/tutorialzine/awesome-project
        При клонировании в текущий каталог, там будет создана папка, в которую поместятся все проектные файлы и скрытая директория .git, с самим репозиторием, или с необходимой информацией о нем. В такой ситуации, для клонируемого репозитория, по умолчанию, будет создана папка с одноименным названием, но его можно залить и в другую директорию, например:

            git clone https://github.com/tutorialzine/awesome-project new-folder

    * ### Подключение к удаленному репозиторию;

        тобы загрузить что-нибудь в удаленный репозиторий, сначала нужно к нему подключиться. Регистрация и установка может занять время, но все подобные сервисы предоставляют хорошую документацию.
        Чтобы связать наш локальный репозиторий с репозиторием на GitHub, выполним следующую команду в терминале. Обратите внимание, что нужно обязательно изменить URI репозитория на свой.

            # This is only an example. Replace the URI with your own repository address.
            $ git remote add origin https://github.com/tutorialzine/awesome-project.git
        Проект может иметь несколько удаленных репозиториев одновременно. Чтобы их различать, мы дадим им разные имена. Обычно главный репозиторий называется origin.

    * ### Отправка изменений на сервер;

        Сейчас самое время переслать наш локальный коммит на сервер. Этот процесс происходит каждый раз, когда мы хотим обновить данные в удаленном репозитории.
        Команда, предназначенная для этого - push. Она принимает два параметра: имя удаленного репозитория (мы назвали наш origin) и ветку, в которую необходимо внести изменения (master — это ветка по умолчанию для всех репозиториев).

            $ git push origin master
            Counting objects: 3, done.
            Writing objects: 100% (3/3), 212 bytes | 0 bytes/s, done.
            Total 3 (delta 0), reused 0 (delta 0)
            To https://github.com/tutorialzine/awesome-project.git
            * [new branch] master -> master

        Эта команда немного похожа на git fetch, с той лишь разницей, что при помощи fetch мы импортируем коммиты в локальную ветку, а при применив push, мы экспортируем их из локальной в удаленную. Если вам необходимо настроить удаленную ветку используйте git remote. Однако пушить надо осторожно, ведь рассматриваемая команда перезаписывает безвозвратно все изменения. В большинстве случаев, ее используют, чтобы опубликовать выгружаемые локальные изменения в центральный репозиторий. А еще ее применяют для того, чтобы поделиться, внесенными в локальный репозиторий, нововведениями, с коллегами или другими удаленными участниками разработки проекта. Подытожив сказанное, можно назвать git push - командой выгрузки, а git pull и git fetch - командами загрузки или скачивания. После того как вы успешно запушили измененные данные, их необходимо внедрить или интегрировать, при помощи команды слияния git merge.
        В зависимости от сервиса, который вы используете, вам может потребоваться аутентифицироваться, чтобы изменения отправились. Если все сделано правильно, то когда вы посмотрите в удаленный репозиторий при помощи браузера, вы увидите файл hello.txt

    * ### Запрос изменений с сервера;

        Если вы сделали изменения в вашем удаленном репозитории, другие пользователи могут скачать изменения при помощи команды pull.

            $ git pull origin master
            From https://github.com/tutorialzine/awesome-project
            * branch master -> FETCH_HEAD
            Already up-to-date.

        Так как новых коммитов с тех пор, как мы склонировали себе проект, не было, никаких изменений доступных для скачивания нет.

        **Как удалить локальный репозиторий**

        Вам не понравился один из ваших локальных Git-репозиториев и вы хотите стереть его со своей машины. Для этого вам всего лишь надо удалить скрытую папку «.git» в корневом каталоге репозитория. Сделать это можно 3 способами:

        * Проще всего вручную удалить эту папку «.git» в корневом каталоге «Git Local Warehouse».
        * Также удалить, не устраивающий вас, репозиторий можно на github. Открываете нужный вам объект и переходите в пункт меню Настройки. Там, прокрутив ползунок вниз, вы попадете в зону опасности, где один из пунктов будет называться «удаление этого хранилища».
        * Последний метод удаления локального хранилища через командную строку, для этого в терминале необходимо ввести следующую команду:

                cd repository-path/
                rm -r .git
                
4. Ветвление

    Во время разработки новой функциональности считается хорошей практикой работать с копией оригинального проекта, которую называют веткой. Ветви имеют свою собственную историю и изолированные друг от друга изменения до тех пор, пока вы не решаете слить изменения вместе. Это происходит по набору причин:

       * Уже рабочая, стабильная версия кода сохраняется.
       * Различные новые функции могут разрабатываться параллельно разными программистами.
       * Разработчики могут работать с собственными ветками без риска, что кодовая база поменяется из-за чужих изменений.
       * В случае сомнений, различные реализации одной и той же идеи могут быть разработаны в разных ветках и затем сравниваться.

    * ### Создание новой ветки;

        Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду branch <name>

            $ git branch amazing_new_feature

        Это создаст новую ветку, пока что точную копию ветки master.

    * ### Переключение между ветками;

        Сейчас, если мы запустим branch, мы увидим две доступные опции:

            $ git branch
            amazing_new_feature
            * master

        master — это активная ветка, она помечена звездочкой. Но мы хотим работать с нашей “новой потрясающей фичей”, так что нам понадобится переключиться на другую ветку. Для этого воспользуемся командой checkout, она принимает один параметр — имя ветки, на которую необходимо переключиться.

            $ git checkout amazing_new_feature

        В Git ветка — это отдельная линия разработки. Git checkout позволяет нам переключаться как между удаленными, так и меду локальными ветками. Это один из способов получить доступ к работе коллеги или соавтора, обеспечивающий более высокую продуктивность совместной работы. Однако тут надо помнить, что пока вы не закомитили изменения, вы не сможете переключиться на другую ветку. В такой ситуации нужно либо сделать коммит, либо отложить его, при помощи команды git stash, добавляющей текущие незакоммиченные изменения в стек изменений и сбрасывающей рабочую копию до HEAD'а репозитория.

    * ### Слияние веток;

        Наша “потрясающая новая фича” будет еще одним текстовым файлом под названием feature.txt. Мы создадим его, добавим и закоммитим:

            $ git add feature.txt
            $ git commit -m "New feature complete.”

        Изменения завершены, теперь мы можем переключиться обратно на ветку master.

            $ git checkout master

        Теперь, если мы откроем наш проект в файловом менеджере, мы не увидим файла feature.txt, потому что мы переключились обратно на ветку master, в которой такого файла не существует. Чтобы он появился, нужно воспользоваться merge для объединения веток (применения изменений из ветки amazing_new_feature к основной версии проекта).

            $ git merge amazing_new_feature

        Теперь ветка master актуальна. Ветка amazing_new_feature больше не нужна, и ее можно удалить.

            $ git branch -d awesome_new_feature

        Если хотите создать копию удаленного репозитория - используйте git clone. Однако если вам нужна только определенная его ветка, а не все хранилище - после git clone выполните следующую команду в соответствующем репозитории:

            git checkout -b <имя ветки> origin/<имя ветки>

        После этого, новая ветка создается на машине автоматически.

        **Как удалять ветки в Git**

        Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде. Но как это сделать?
        Для локально расположенных веток существует команда:

            git branch -d local_branch_name

        где флажок -d являющийся опцией команды git branch - это сокращенная версия ключевого слова --delete, предназначенного для удаления ветки, а local_branch_name – название ненужной нам ветки.
        Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку с таким содержанием:

            Error: Cannot delete branch local_branch_name checked out at название_директории
            Так что при удалении ветвей, обязательно переключитесь на другой branch.

    * ### Разрешение конфликтов при слиянии

        Помимо сценария, описанного в предыдущем пункте, конфликты регулярно возникают при слиянии ветвей или при отправке чужого кода. Иногда конфликты исправляются автоматически, но обычно с этим приходится разбираться вручную — решать, какой код остается, а какой нужно удалить.
        Давайте посмотрим на примеры, где мы попытаемся слить две ветки под названием john_branch и tim_branch. И Тим, и Джон правят один и тот же файл: функцию, которая отображает элементы массива.
        Джон использует цикл:

            // Use a for loop to console.log contents.
            for(var i=0; i<arr.length; i++) {
            console.log(arr[i]);
            }

        Тим предпочитает forEach:

            // Use forEach to console.log contents.
            arr.forEach(function(item) {
            console.log(item);
            });

        Они оба коммитят свой код в соответствующую ветку. Теперь, если они попытаются слить две ветки, они получат сообщение об ошибке:

            $ git merge tim_branch
            Auto-merging print_array.js
            CONFLICT (content): Merge conflict in print_array.js
            Automatic merge failed; fix conflicts and then commit the result.

        Система не смогла разрешить конфликт автоматически, значит, это придется сделать разработчикам. Приложение отметило строки, содержащие конфликт:

            <<<<<<< HEAD // Use a for loop to console.log contents. for(var i=0; i<arr.length;

        Над разделителем ======= мы видим последний (HEAD) коммит, а под ним - конфликтующий. Таким образом, мы можем увидеть, чем они отличаются и решать, какая версия лучше. Или вовсе написать новую. В этой ситуации мы так и поступим, перепишем все, удалив разделители, и дадим git понять, что закончили.

            // Not using for loop or forEach.
            // Use Array.toString() to console.log contents.
            console.log(arr.toString());

        Когда все готово, нужно закоммитить изменения, чтобы закончить процесс:

            $ git add -A
            $ git commit -m "Array printing conflict resolved."

        Как вы можете заметить, процесс довольно утомительный и может быть очень сложным в больших проектах. Многие разработчики предпочитают использовать для разрешения конфликтов клиенты с графическим интерфейсом. (Для запуска нужно набрать git mergetool).

5. Настройка *.gitignore*
    * ### Создание файла *.gitignore*;

        В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

        * Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
        * Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
        * Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

    * ### Примеры файлов

        Вот хорошие примеры файлов, которые нужно игнорировать:

        * Логи
        * Артефакты систем сборки
        * Папки node_modules в проектах node.js
        * Папки, созданные IDE, например, Netbeans или IntelliJ
        * Разнообразные заметки разработчика.

        Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:

            *.log
            build/
            node_modules/
            .idea/
            my_notes.txt

        Символ слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.

6. ### Git bash и git.io 

    Руководствуясь часто встречающимися, при изучении системы, вопросами новичков, разберем еще несколько непонятных словосочетаний.

    * Git Bash(Bourne Again Shell) — это приложение, являющееся эмулятором командной строки и предоставляющее, операционной системе, некоторые распространенные утилиты bash и собственно саму систему Git. Это терминал, используемый для взаимодействия с персональным компьютером, посредством письменных команд.
    * URL-адреса хранилищ на Гитхабе могут быть довольно длинными, из-за больших имен репозиториев и файлов. Работать с такими ссылками очень не удобно. Поэтому сайт github.io создал git.io — неплохой сервис по преобразованию этих длинных и беспорядочных URL-адресов в более короткие и понятные. Сайт был создан в 2011 году и вплоть до недавнего времени отлично справлялся со своими обязанностями. Однако в начале этого года компания Гитхаб, из-за участившихся попыток хакеров использовать сайт в злонамеренных целях, остановила работу сервиса, а чем известила пользователей в своем блоге. Разработчики популярного ресурса рекомендуют пользоваться другими URL-cutter’ами, пока работа сервиса не будет налажена.

7. ### Шпаргалка по основным командам

* git add

    Команда git add добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.

* git status

    Команда git status показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

* git diff

    Команда git diff используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

* git difftool

    Команда git difftool просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика git diff.

* git commit

    Команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

* git reset

    Команда git reset, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель HEAD и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра --hard, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

* git rm

    Команда git rm используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на git add с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

* git mv

    Команда git mv — это всего лишь удобный способ переместить файл, а затем выполнить git addдля нового файла и git rm для старого.

* git clean

    Команда git clean используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

**Шпаргалка по ветвлению и слиянию**

* git branch

    Команда git branch — это своего рода “менеджер веток”. Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

* git checkout

    Команда git checkout используется для переключения веток и выгрузки их содержимого в рабочую директорию.

* git merge

    Команда git merge используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

* git mergetool

    Команда git mergetool просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

* git log

    Команда git log используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

* git stash

    Команда git stash используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку.

* git tag

    Команда git tag используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

* Шпаргалка по совместной работе и обновлению проектов

    Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

* git fetch

    Команда git fetch связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

* git pull 

    Команда git pull работает как комбинация команд git fetch и git merge, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

* git push

    Команда git push используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

* git remote

    Команда git remote служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

* git archive

    Команда git archive используется для упаковки в архив указанных коммитов или всего репозитория.

* git submodule

    Команда git submodule используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.

**Шпаргалка по осмотру и сравнению**

* git show

    Команда git show отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.

* git shortlog

    Команда git shortlog служит для подведения итогов команды git log. Она принимает практически те же параметры, что и git log, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

* git describe

    Команда git describe принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

**Шпаргалка по отладке**

В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

* git bisect

    Команда git bisect — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

* git blame

    Команда git blame выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

* git grep

    Команда git grep используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.    
